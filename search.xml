<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP开发安全问题总结]]></title>
    <url>%2Fpost%2Ffafef4eb.html</url>
    <content type="text"><![CDATA[引言提供Internet服务时，在开发代码时必须始终牢记安全性。大多数PHP脚本对安全问题都不敏感；特别是对大多数没有经验的开发者来说。但是，基于对代码重要性，非常有必要采用一致的安全策略。当你在服务器上放置任何财产有关的东西时，很可能会有人试图随便破解它。创建一个论坛程序或任何类型的购物车，被攻击的可能性就会有所上升。 背景以下是保护您的网络内容的一些一般安全准则： 不要相信表单利用表单攻击是很寻常的。通过使用简单的JavaScript技巧，您可以限制您的表单以仅允许的字段。对于一般的Javascript前台验证，由于无法得知用户的行为，例如用户关闭了浏览器的Javascript引擎或发布自定义表单数据时，客户端验证会弹出窗口。 用户主要通过表单参数与脚本进行交互，因此它们也成了最大的安全风险。这告诉我们什么？要始终验证传递给PHP脚本的任何数据。在本文中，我们将向您展示如何分析和防止跨站点脚本（XSS）攻击，严重的话会劫持你的用户凭据。您还将了解如何防止可能污染或破坏数据的MySQL注入攻击。 不要相信用户要始终假设您的网站收集的每一条数据都充满了有害的代码。对每条数据都要进行过滤，即使你肯定没有人试图攻击你的应用。 关闭全局变量最大安全漏洞是启用了register_globals配置参数。不过幸运的是，它在PHP 4.2及更高版本中默认关闭。如果register_globals打开，那么你可以通过在服务器的php.ini文件中将register_globals变量设置为Off来禁用此功能。 1register_globals = Off 新手程序员查看注册的全局变量是一种便利，但他们没有意识到这个设置有多危险。启用了全局变量的服务器会自动将全局变量分配给任何表单参数。为了了解这是如何工作的以及为什么这是危险的，让我们看一个例子。 假设您有一个名为process.php的脚本，它将表单数据输入到您的用户数据库中。原始表单看起来像这样： 1&lt;input name="username" type="text" size="15" maxlength="64"&gt; 运行process.php时，启用了已注册全局变量的PHP会将此参数的值放入$ username变量中。通过$ _POST [&#39;username&#39;]或$ _GET [&#39;username&#39;]可以节省一些打字输入。但不幸的是，这也造成了一个安全问题。因为PHP为通过GET或POST参数发送到脚本的任何值设置了一个变量，如果你没有显式初始化变量并且你不希望有人操纵它，这是一个大问题。 以下面的脚本为例 - 如果$ authorized变量为true，它会向用户显示机密数据。在正常情况下，仅当用户已通过假设的authenticated_user()函数进行了正确的身份验证时，$ authorized变量才会设置为true。但是如果你有register_globals活动，任何人都可以发送一个GET参数，如authorized = 1来覆盖这个： 123456&lt;?php// Define $authorized = true only if user is authenticatedif (authenticated_user()) &#123; $authorized = true;&#125;?&gt; 这个场景寓意是你应该从预定义的服务器变量中提取表单数据。通过发布的表单传递到您的网页的所有数据都会自动存储在名为$ _POST的大型数组中，并且所有GET数据都存储在名为$ _GET的大型数组中。文件上载信息存储在名为$ _FILES的特殊数组中。此外，还有一个名为$ _REQUEST的组合变量。 要从POST方法表单访问用户名字段，请使用$ _POST [&#39;username&#39;]。如果用户名在URL中，请使用$ _GET [&#39;username&#39;]。如果您不关心值的来源，请使用$ _REQUEST [&#39;username&#39;]。 12345&lt;?php$post_value = $_POST['post_value'];$get_value = $_GET['get_value'];$some_variable = $_REQUEST['some_value']; ?&gt; $ _REQUEST是$ _GET，$ _POST和$ _COOKIE数组的联合。如果您有两个或多个相同参数名称的值，请注意PHP使用的值。默认顺序是cookie，POST，然后是GET。 推荐的安全配置选项SQL注入攻击防止基本的XSS攻击使用SafeHTML使用单向哈希保护数据使用Mcrypt加密数据生成随机密码查看原文]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitee(码云)、Github同时配置ssh key]]></title>
    <url>%2Fpost%2Fc70e21e5.html</url>
    <content type="text"><![CDATA[一、创建gitee和github的ssh key12cd ~/.sshssh-keygen -t rsa -C "xxxxx@xxxxx.com" 替换正确的邮箱，按enter 12Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/FlyingHorse/.ssh/id_rsa): id_rsa.gitee 创建gitee的ssh key时输入id_rsa.gitee，创建github的ssh key时输入id_rsa.github123456789101112131415161718Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in id_rsa.gitee.Your public key has been saved in id_rsa.gitee.pub.The key fingerprint is:SHA256:lmjU8A4k+r6liYJmENBPM/7Frx3XDg98VeWvIQ9dLyw xxxxx@xxxxx.comThe key's randomart image is:+---[RSA 2048]----+| . . o o||. ..+o + ..||. .+ oo.o +||. .o. +o. o .+|| . ..o.S. .E.=.o||. . ... o ==o+ ||o . . o o *o ||oo . = . . o ||o.. + |+----[SHA256]-----+ 一路按enter，知道输出如图 二、把public key复制到gitee或github12345cat id_rsa.gitee.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDZbvgUEj3XAXH4HkW27ibdXgV6VHdrA9/WdSDHtiiC55mjPvxj3OtPxIbpeJmhWyHiJWR6uUuK+gkb//O51uWCPhHqxKR7+45tZ9jHqXW+hEKPp+odQgc+3hiHAjTkn3JGeIJlQp2UdJCDHBrp+kcgVeg91+y7cU3ufaUQ/hpDrCgn6uvwjwJgnDhV9DYi+gFUFe7LUwa1o4nfwg43ycuOOuT7c6VO2dj/0pLRUVTPQYu/C3kaaPVedir7mKIu/dM6Ec44bhYTp1Dqqp8BO42Cfo+n+dempqYTe2wcPvuDjSj884IATc/KvBfc86Yd2Uj7NI7li90Y3i6adoxUIWQh xxxxx@xxxxx.com 查看公钥，gitee输入id_rsa.gitee.pub，github输入id_rsa.github.pub 将第二行到结尾的内容复制到gitee或github的ssh中保存 三、创建配置解决ssh冲突在.ssh文件夹中创建config文件，添加以下内容以区分两个ssh key 1234567891011# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa.gitee# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa.github 四、测试连接输入 1ssh -T git@gitee.com 若返回如下图，则gitee则连接正常 1Welcome to Gitee.com, yourname! 输入 1ssh -T git@github.com 若返回如下图，则github则连接正常 1Hi yourname! You've successfully authenticated, but GitHub does not provide shell access.]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用PHPStrom安装laravel]]></title>
    <url>%2Fpost%2F793c95ad.html</url>
    <content type="text"><![CDATA[项目安装设置打开软件选择create new porject,进入创建项目窗口，选择Composer Project。按照截图所示设置相应的Location（安装目录）、勾选Download composer.phar from getcomposer.org、Package输入laravel/laravel并在查找的结果中选择laravel/laravel。最后点击Create开始创建。整个安装过程的时间由于网络的环境不同有所差异。 安装完成后可以在phpstrom的Event Log查看的相应的消息。 Composer​ Project was successfully created by Composer.​ Show in log 点击Show in log就可以查看具体的安装日志。 至此这个项目就相当安装好了。 开发前的设置设置版本控制打开project工作区全选这个项目下的文件，然后取消选择composer.phar。 然后在顶部的菜单栏里选择VCS-&gt;Enable Version Control Integration 这时候会弹出版本控制工具的对话框。我这边是设置为Git。 点击OK确定。选择Version Control会弹出如下界面，点击绿色小箭头。 此时就会弹出git的提交信息界面，按照截图所示进行操作： 选择要git提交的文件，因为是第一次提交可以把Before Commit下的Optimize import和Perform code analysis取消掉。最后填写Commit Message点击Commit确认提交。至此git的初始设置就相当于完成了。 安装laravel支持插件实现代码自动补全和检查可以安装Laravel Plugin这个插件。点击File-&gt;Plugin在Marketplace里搜索Laravel Plugin选择安装并重启IDE。重启后再打开设置界面。找到Languages &amp; Frameworks-&gt;PHP-&gt;Laravel勾选Enable plugin for this project。点击Aplay确认应用。 安装Laravel Debugbar 扩展包在菜单栏依次选择Tools-&gt;composer-&gt;Manage dependencies。在弹出的窗口里输入barryvdh/laravel-debugbar。选择要安装的版本Version to install，我这边选择最新的稳定版V3.2.1 再次打开部署的网站页面，就可以看到优雅的debug bar了。 安装其他的扩展包也可以按照这个方法进行安装。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>PHP</tag>
        <tag>PHPstrom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 进行数据迁移（migration）报错解决办法]]></title>
    <url>%2Fpost%2Fa754c2fd.html</url>
    <content type="text"><![CDATA[Laravel 5.4 把默认数据库字符集更改成 utf8mb4，作为对存储 emojis 的支持。只要你运行的是 MySQL v5.7.7 及更高版本，那么你就下面提到的错误。 SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes (SQL: alter table users add unique users_email_unique (email)) 对于 MariaDB 或旧版本的 MySQL 的程序，可以找到：/app/Providers/AppServiceProvider.php 在 boot 方法内设置默认字符串的长度： 123456use Illuminate\Support\Facades\Schema;public function boot()&#123; Schema::defaultStringLength(191);&#125; 再次执行: 1php artisan migrate Migration table created successfully.Migrating: 2014_10_12_000000_create_users_tableMigrated: 2014_10_12_000000_create_users_tableMigrating: 2014_10_12_100000_create_password_resets_tableMigrated: 2014_10_12_100000_create_password_resets_table]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Facebook账号一键登录]]></title>
    <url>%2Fpost%2Fb05283f6.html</url>
    <content type="text"><![CDATA[公司最近做的一个项目要求使用Facebook实现一键登录的功能。所谓的Facebook登录就是获取用户在Facebook的资料，通过这些资料（邮箱等）登录或者注册目标网站。这中间Facebook提供了相应的接口，通过这个接口获取用户授权就能拿到相应的用户资料。虽然整个过程完成下来还算比较顺利。这边还是要做一下记录。 申请应用及配置在使用之前，需要先在Facebook开发者平台注册账号，新建应用，然后获取新建应用的编号APPID。相应的流程开发平台写的还是相对比较清楚的，这里就不一一赘述。其中要注意的是：有效 OAuth 跳转 URL要填写正确。 还有一个是隐私政策网站的填写。这个关乎应用能不能的公开发布。找到开发平台的控制面板下面有个设置-&gt;基本。在隐私权政策网址里可以填http://wp4fb.com/how-to-add-a-privacy-policy-to-your-apps/（这个不是唯一的，填写的地址有效即可）。然后保存更改。 然后就可以点击应用发布开关，弹窗提示点击确定即可。最后效果是这样的： 相关代码1. 检查登录状态加载网页时应采取的第一步是检查用户是否已使用 Facebook 登录功能登录您的应用。调用 FB.getLoginStatus 即可开始此流程。此函数会触发 Facebook 调用，获取登录状态，并调用包含结果的回调函数。 下面是将在页面加载期间运行以检查用户登录状态的部分代码： 123FB.getLoginStatus(function(response) &#123; statusChangeCallback(response);&#125;); 提供给回调的response对象包括的字段： 12345678910111213141516&#123; // 用户登录状态 status: 'connected', authResponse: &#123; // 包括应用用户的访问口令 accessToken: '...', // 口令到期且需要更新的 UNIX 时间 expiresIn:'...', // 登录过期和请求重新授权之前的时长（以秒为单位） reauthorize_required_in:'...' // 经签名的参数，其中包括应用用户的信息。 signedRequest:'...', // 应用用户的编号 userID:'...' &#125;&#125; 知道用户的登录状态后，应用就可以执行以下操作之一： 如果用户登录了 Facebook 和您的应用，可将他们重定向至应用的登录后体验。 如果用户未登录您的应用，或未登录 Facebook，则可以通过 FB.login()呈现登录对话框，以此提示他们登录，或显示“登录”按钮。 2. 使用JavaScript SDK提供的登录按钮代码 12345678&lt;div id="fb-root"&gt;&lt;/div&gt;&lt;script&gt;(function(d, s, id) &#123; var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = 'https://connect.facebook.net/zh_CN/sdk.js#xfbml=1&amp;version=v3.2&amp;appId=申请的应用编号&amp;autoLogAppEvents=1'; fjs.parentNode.insertBefore(js, fjs);&#125;(document, 'script', 'facebook-jssdk'));&lt;/script&gt; 按钮 1&lt;div class="fb-login-button" data-size="large" data-button-type="continue_with" data-auto-logout-link="false" data-use-continue-as="false"&gt;&lt;/div&gt; 3. 获取用户信息123456789101112131415&lt;script&gt; function fb_login() &#123; FB.login(function(response) &#123; if (response.status === 'connected') &#123; // 获取用户id、Email、名称等 FB.api('/me?fields=id,email,first_name,last_name,gender', function(response) &#123; // 获取信息后的相关操作 console.log(response); &#125;); &#125; else &#123; alert('login fail'); &#125; &#125;, &#123;scope: 'public_profile,email'&#125;); &#125;&lt;/script&gt; 4. 完整实例代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; window.fbAsyncInit = function() &#123; FB.init(&#123; appId: '', // 这里需要改成15位你创建的Facebook应用编号 cookie: true, xfbml: true, version: 'v3.2' &#125;); FB.AppEvents.logPageView(); &#125;; (function(d, s, id) &#123; var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) &#123; return; &#125; js = d.createElement(s); js.id = id; js.src = "//connect.facebook.net/en_US/sdk.js"; fjs.parentNode.insertBefore(js, fjs); &#125;(document, 'script', 'facebook-jssdk'));&lt;/script&gt;&lt;script&gt; function fb_login() &#123; FB.login(function(response) &#123; if (response.status === 'connected') &#123; FB.api('/me?fields=id,email,first_name,last_name,gender', function(response) &#123; // 获取信息后的相关操作 &#125;); &#125; else &#123; alert('login fail'); &#125; &#125;, &#123;scope: 'public_profile,email'&#125;); &#125;&lt;/script&gt; &lt;div class="login-btn-box" &gt; &lt;button onclick="fb_login();"&gt;Login with Facebook&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 总结Facebook JavaScript SDK在最新的3.2版本中跳转 URI 和 JavaScript SDK 强制使用 HTTPS。Facebook是使用标准的 OAuth 客户端口令流程。其授权过程跟其他OAuth没什么区别，按照官网的流程走一般都能成功。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPStrom文件修改标星提示]]></title>
    <url>%2Fpost%2F9ffb46c.html</url>
    <content type="text"><![CDATA[phpstrom设置标星提示文件修改 Eclipse中文件修改后没有保存前文件都会有星号提示，phpstrom默认没有提示，但是可以通过如下设置完成： File -&gt; Settings -&gt; Editor -&gt; General -&gt; Editor Tabs: Mark modified (*)]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>phpstrom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码风格规范]]></title>
    <url>%2Fpost%2Fe54bdc58.html</url>
    <content type="text"><![CDATA[编码风格指南本指南扩展和扩展了基本编码标准PSR-1。 本指南的目的是在扫描来自不同作者的代码时减少认知摩擦。它通过枚举一组共享规则和对如何格式化PHP代码的期望来实现。 这里的风格规则源于各个成员项目之间的共性。当各个作者跨多个项目进行协作时，在所有这些项目中使用一套指南会很有帮助。因此，本指南的好处不在于规则本身，而在于共享这些规则。 本文档中的关键词“必须”，“必须”，“必需”，“应该”，“不应该”，“应该”，“不应该”，“推荐”，“可以”和“可选”按照RFC 2119中的描述进行解释。 1. 概览 代码 必须 遵循 [PSR-1] 中的编码规范 。 代码 必须 使用 4 个空格符而不是「Tab 键」进行缩进。 每行的字符数 应该 软性保持在 80 个之内，理论上 一定不可 多于 120 个，但 一定不可 有硬性限制。 每个 namespace 命名空间声明语句和 use 声明语句块后面，必须 插入一个空白行。 类的开始花括号（{） 必须 写在函数声明后自成一行，结束花括号（}）也 必须 写在函数主体后自成一行。 方法的开始花括号（{） 必须 写在函数声明后自成一行，结束花括号（}）也 必须 写在函数主体后自成一行。 类的属性和方法 必须 添加访问修饰符（private、protected 以及 public），abstract 以及 final 必须 声明在访问修饰符之前，而 static 必须 声明在访问修饰符之后。 控制结构的关键字后 必须 要有一个空格符，而调用方法或函数时则 一定不可 有。 控制结构的开始花括号（{） 必须 写在声明的同一行，而结束花括号（}） 必须 写在主体后自成一行。 控制结构的开始左括号后和结束右括号前，都 一定不可 有空格符。 1.1. 示例本示例将作为下文规则的快速概览： 12345678910111213141516171819202122232425&lt;?phpnamespace Vendor\Package;use FooInterface;use BarClass as Bar;use OtherVendor\OtherPackage\BazClass;class Foo extends Bar implements FooInterface&#123; public function sampleMethod($a, $b = null) &#123; if ($a === $b) &#123; bar(); &#125; elseif ($a &gt; $b) &#123; $foo-&gt;bar($arg1); &#125; else &#123; BazClass::bar($arg2, $arg3); &#125; &#125; final public static function bar() &#123; // method body &#125;&#125; 2. 通则2.1. 基本编码准则代码 必须 符合 PSR-1 中的所有规范。 2.2. 文件所有 PHP 文件 必须 使用 Unix LF (linefeed) 作为行的结束符。 所有 PHP 文件 必须 以一个空白行作为结束。 纯 PHP 代码文件 必须 省略最后的 ?&gt; 结束标签。 2.3. 行行的长度 一定不可 有硬性的约束。 软性的长度约束 必须 要限制在 120 个字符以内，若超过此长度，带代码规范检查的编辑器 必须 要发出警告，不过 一定不可 发出错误提示。 每行 不该 多于80个字符，大于80字符的行 应该 折成多行。 非空行后 一定不可 有多余的空格符。 空行 可以 使得阅读代码更加方便以及有助于代码的分块。 每行 一定不可 存在多于一条语句。 2.4. 缩进代码 必须 使用 4 个空格来进行缩进， 并且 一定不能 使用 tab 键来缩进。 注：仅使用空格，而不是使用空格和 tab 键混在一起， 能帮助避免在查看代码差异，打补丁，查看提交历史，以及进行注解时产生问题。使用空格也使得代码对齐更轻松。 2.5. 关键字与 True/False/NullPHP 的 关键字 必须 使用小写形式。 PHP 的常量 true， false， 还有 null 必须 使用小写形式。 3. 命名空间和使用声明namespace 声明之后 必须 存在一个空行。 所有的 use 声明 必须 位于 namespace 声明之后。 每条 use 声明 必须 只有一个 use 关键字。 use 语句块之后 必须 存在一个空行。 例如： 12345678&lt;?phpnamespace Vendor\Package;use FooClass;use BarClass as Bar;use OtherVendor\OtherPackage\BazClass;// ... additional PHP code ... 4. 类、属性和方法此处的「类」泛指所有的「class类」、「接口」以及「traits 可复用代码块」。 4.1. 扩展与继承关键词 extends 和 implements 必须 写在类名称的同一行。 类的开始花括号 必须 独占一行，结束花括号也 必须 在类主体后独占一行。 1234567891011&lt;?phpnamespace Vendor\Package;use FooClass;use BarClass as Bar;use OtherVendor\OtherPackage\BazClass;class ClassName extends ParentClass implements \ArrayAccess, \Countable&#123; // constants, properties, methods&#125; implements 的继承列表也 可以 分成多行，这样的话，每个继承接口名称都 必须 分开独立成行，包括第一个。 1234567891011121314&lt;?phpnamespace Vendor\Package;use FooClass;use BarClass as Bar;use OtherVendor\OtherPackage\BazClass;class ClassName extends ParentClass implements \ArrayAccess, \Countable, \Serializable&#123; // constants, properties, methods&#125; 4.2. 属性每个属性都 必须 添加访问修饰符。 一定不可 使用关键字 var 声明一个属性。 每条语句 一定不可 定义超过一个属性。 不该 使用下划线作为前缀，来区分属性是 protected 或 private。 以下是属性声明的一个范例： 1234567&lt;?phpnamespace Vendor\Package;class ClassName&#123; public $foo = null;&#125; 4.3. 方法所有方法都 必须 添加访问修饰符。 不该 使用下划线作为前缀，来区分方法是 protected 或 private 访问修饰符。 方法名称后 一定不可 有空格符，其开始花括号 必须 独占一行，结束花括号也 必须 在方法主体后单独成一行。参数左括号后和右括号前 一定不可 有空格。 一个标准的方法声明可参照以下范例，留意其括号、逗号、空格以及花括号的位置。 12345678910&lt;?phpnamespace Vendor\Package;class ClassName&#123; public function fooBarBaz($arg1, &amp;$arg2, $arg3 = []) &#123; // method body &#125;&#125; 4.4. 方法的参数参数列表中，每个逗号后面 必须 要有一个空格，而逗号前面 一定不可 有空格。 有默认值的参数，必须 放到参数列表的末尾。 12345678910&lt;?phpnamespace Vendor\Package;class ClassName&#123; public function foo($arg1, &amp;$arg2, $arg3 = []) &#123; // method body &#125;&#125; 参数列表 可以 分列成多行，这样，包括第一个参数在内的每个参数都 必须 单独成行。 拆分成多行的参数列表后，结束括号以及方法开始花括号 必须 写在同一行，中间用一个空格分隔。 12345678910111213&lt;?phpnamespace Vendor\Package;class ClassName&#123; public function aVeryLongMethodName( ClassTypeHint $arg1, &amp;$arg2, array $arg3 = [] ) &#123; // method body &#125;&#125; 4.5. abstract, final, 和 static 关键字需要添加 abstract 或 final 声明时，必须 写在访问修饰符前，而 static 则 必须 写在其后。 1234567891011121314&lt;?phpnamespace Vendor\Package;abstract class ClassName&#123; protected static $foo; abstract protected function zim(); final public static function bar() &#123; // method body &#125;&#125; 4.6. 方法及函数调用方法及函数调用时，方法名或函数名与参数左括号之间 一定不可 有空格，参数右括号前也 一定不可 有空格。每个逗号前 一定不可 有空格，但其后 必须 有一个空格。 1234&lt;?phpbar();$foo-&gt;bar($arg1);Foo::bar($arg2, $arg3); 参数 可以 分列成多行，此时包括第一个参数在内的每个参数都 必须 单独成行。 123456&lt;?php$foo-&gt;bar( $longArgument, $longerArgument, $muchLongerArgument); 5. 控制结构控制结构的基本规范如下： 控制结构关键词后 必须 有一个空格。 左括号 ( 后 一定不可 有空格。 右括号 ) 前也 一定不可 有空格。 右括号 ) 与开始花括号 { 间 必须 有一个空格。 结构体主体 必须 要有一次缩进。 结束花括号 } 必须 在结构体主体后单独成行。 每个结构体的主体都 必须 被包含在成对的花括号之中，这能让结构体更加标准化，以及减少加入新行时，出错的可能性。 5.1. if, elseif, else标准的 if 结构如下代码所示，请留意「括号」、「空格」以及「花括号」的位置，注意 else 和 elseif 都与前面的结束花括号在同一行。 12345678&lt;?phpif ($expr1) &#123; // if body&#125; elseif ($expr2) &#123; // elseif body&#125; else &#123; // else body;&#125; 应该 使用关键词 elseif 代替所有 else if ，以使得所有的控制关键字都像是单独的一个词。 5.2. switch, case标准的 switch 结构如下代码所示，留意括号、空格以及花括号的位置。 case 语句 必须 相对 switch 进行一次缩进，而 break 语句以及 case 内的其它语句都 必须 相对 case 进行一次缩进。 如果存在非空的 case 直穿语句，主体里 必须 有类似 // no break 的注释。 1234567891011121314151617&lt;?phpswitch ($expr) &#123; case 0: echo 'First case, with a break'; break; case 1: echo 'Second case, which falls through'; // no break case 2: case 3: case 4: echo 'Third case, return instead of break'; return; default: echo 'Default case'; break;&#125; 5.3. while, do while一个规范的 while 语句应该如下所示，注意其「括号」、「空格」以及「花括号」的位置。 1234&lt;?phpwhile ($expr) &#123; // structure body&#125; 同样的，标准的 do while 语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。 1234&lt;?phpdo &#123; // structure body;&#125; while ($expr); 5.4. for标准的 for 语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。 1234&lt;?phpfor ($i = 0; $i &lt; 10; $i++) &#123; // for body&#125; 5.5. foreach标准的 foreach 语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。 1234&lt;?phpforeach ($iterable as $key =&gt; $value) &#123; // foreach body&#125; 5.6. try, catch标准的 try catch 语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。 12345678&lt;?phptry &#123; // try body&#125; catch (FirstExceptionType $e) &#123; // catch body&#125; catch (OtherExceptionType $e) &#123; // catch body&#125; 6. 闭包闭包声明时，关键词 function 后以及关键词 use 的前后都 必须 要有一个空格。 开始花括号 必须 写在声明的同一行，结束花括号 必须 紧跟主体结束的下一行。 参数列表和变量列表的左括号后以及右括号前，一定不可 有空格。 参数和变量列表中，逗号前 一定不可 有空格，而逗号后 必须 要有空格。 闭包中有默认值的参数 必须 放到列表的后面。 标准的闭包声明语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。 12345678&lt;?php$closureWithArgs = function ($arg1, $arg2) &#123; // body&#125;;$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) &#123; // body&#125;; 参数列表以及变量列表 可以 分成多行，这样，包括第一个在内的每个参数或变量都 必须 单独成行，而列表的右括号与闭包的开始花括号 必须 放在同一行。 以下几个例子，包含了参数和变量列表被分成多行的多情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php$longArgs_noVars = function ( $longArgument, $longerArgument, $muchLongerArgument) &#123; // body&#125;;$noArgs_longVars = function () use ( $longVar1, $longerVar2, $muchLongerVar3) &#123; // body&#125;;$longArgs_longVars = function ( $longArgument, $longerArgument, $muchLongerArgument) use ( $longVar1, $longerVar2, $muchLongerVar3) &#123; // body&#125;;$longArgs_shortVars = function ( $longArgument, $longerArgument, $muchLongerArgument) use ($var1) &#123; // body&#125;;$shortArgs_longVars = function ($arg) use ( $longVar1, $longerVar2, $muchLongerVar3) &#123; // body&#125;; 注意，闭包被直接用作函数或方法调用的参数时，以上规则仍然适用。 12345678&lt;?php$foo-&gt;bar( $arg1, function ($arg2) use ($var1) &#123; // 主体 &#125;, $arg3); 7. 总结本指南故意删除了许多风格与实践， 它们包括但不限于： 全局变量和常量的声明 函数声明 运算符与赋值 行间对齐 注释与文档描述块 类名前缀与后缀 最佳实践 本指南将来的修订和扩展 可能 会弥补上述或其他风格与最佳实践。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PSR</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 基本代码标准]]></title>
    <url>%2Fpost%2Fae1a60a8.html</url>
    <content type="text"><![CDATA[PHP标准建议根据PSR Workflow Bylaw，每个PSR都具有正在处理的状态。一旦提案通过了入口投票，它将在此处列为“草稿”。除非PSR标记为“已接受”，否则可能会发生变化。草稿可能会发生巨大变化，但审核只会有微小的变化。 As also described in the PSR Workflow Bylaw。提案的编辑或编辑们基本上是PSR的主要贡献者和作者，他们得到两位投票成员的支持。这些投票成员是协调员，负责管理审查阶段和投票以及二次发起人。 PSR-1：基本编码标准标准的这一部分包括应该被认为是确保共享PHP代码之间高水平技术互操作性所需的标准编码元素。 本文档中的关键词“必须”，“必须”，“必需”，“应该”，“不应该”，“应该”，“不应该”，“推荐”，“可以”和“可选”按照RFC 2119中的描述进行解释。 1. 概述 文件必须只使用&lt;?php和&lt;?=标签。 对于PHP代码，文件必须仅使用没有BOM的UTF-8。 文件应该声明符号（类，函数，常量等）或引起副作用（例如生成输出，更改.ini设置等），但不应该同时出现。 命名空间和类必须遵循“自动加载”PSR：[PSR-0，PSR-4]。 类名必须使用首字母大写的驼峰式进行声明。 类常量必须以全部大写形式用下划线分隔符声明。 方法名必须使用首字母小写的驼峰式进行。 2. 文件2.1. PHP标签PHP代码必须使用长标签&lt;?php?&gt;或短输出标签&lt;?=?&gt;；不能使用其他标签变体。 2.2. 字符编码PHP代码必须只使用不带BOM的UTF-8编码。 2.3. 副作用一份 PHP 文件中 应该 要不就只定义新的声明，如类、函数或常量等不产生 副作用 的操作，要不就只书写会产生 副作用 的逻辑操作，但 不该 同时具有两者。 「副作用」(side effects) 一词的意思是，仅仅通过包含文件，不直接声明类、函数和常量等，而执行的逻辑操作。 「副作用」包含却不仅限于：生成输出，明确使用require或include，连接到外部服务，修改ini设置，发出错误或异常，修改全局或静态变量，读取或写入一个文件，等等。 以下是具有声明和副作用的文件示例;即要避免的一个例子： 123456789101112131415&lt;?php// side effect: change ini settingsini_set('error_reporting', E_ALL);// side effect: loads a fileinclude "file.php";// side effect: generates outputecho "&lt;html&gt;\n";// declarationfunction foo()&#123; // function body&#125; 以下示例是包含没有副作用的声明的文件;即效仿的例子： 1234567891011121314&lt;?php// declarationfunction foo()&#123; // function body&#125;// conditional declaration is *not* a side effectif (! function_exists('bar')) &#123; function bar() &#123; // function body &#125;&#125; 3. 命名空间和类名命名空间和类名 必须 遵循『自动加载』规范：[PSR-0，PSR-4]。 这意味着每个类都独立为一个文件，并且至少在一个层次的命名空间内，那就是：顶级组织名（vendor name）。 类名 必须大写开头的驼峰命名方式声明。 PHP 5.3 及更高版本的代码 必须 使用正式的命名空间。 例如 1234567&lt;?php// PHP 5.3 and later:namespace Vendor\Model;class Foo&#123;&#125; PHP 5.2 及更低版本 应该 使用伪命名空间，约定俗成，以顶级组织名称 Vendor_ 为类名前缀： 12345&lt;?php// PHP 5.2.x and earlier:class Vendor_Model_Foo&#123;&#125; 4. 类的常量、属性和方法此处的「类」指代所有的类、接口以及可复用代码块（traits） 4.1. 常量类的常量中所有字母都 必须 大写，词间以下划线分隔。例如： 12345678&lt;?phpnamespace Vendor\Model;class Foo&#123; const VERSION = '1.0'; const DATE_APPROVED = '2012-06-01';&#125; 4.2. 属性类的属性命名 可以 遵循： 大写开头的驼峰式 小写开头的驼峰式 下划线分隔式 本规范不做强制要求，但无论遵循哪种命名方式，都 应该 在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。 4.3. 方法方法名称 必须 用小写开头的驼峰命名规范。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PSR</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
</search>
