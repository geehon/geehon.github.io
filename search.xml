<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[创建一个基本的Restful Crud API]]></title>
    <url>%2Fpost%2F9bb179b9.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于如何判断客户端类型]]></title>
    <url>%2Fpost%2F512841c.html</url>
    <content type="text"><![CDATA[开发应用有时候会涉及到针对不同的访问类型提供不同的业务处理。以下是分别使用JavaScript和PHP进行判断的简单介绍。使用JavaScript判断首先来了解一下Navigator 对象，Navigator对象包含有关浏览器的信息，通过该对象的属性可以判断访问的客户端类型。Navigator具体有哪些属性可以访问Navigator属性使用方法userAgent属性：使用正则表达式判断navigator.userAgent的信息。&lt;script type=&quot;text/javascript&quot;&gt; function browserRedirect() { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == &quot;ipad&quot;; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;; var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;; var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;; if (!(bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) ) { // 跳转到A页面 window.location.href=&quot;A页面&quot;; } } browserRedirect(); &lt;/script&gt; 使用PHP判断具体原理是利用$_SERVER[]这个数组。客户端对应用进行访问的时候$_SERVER[]会携带客户端类型的相关信息，具体的在代码注释里有详细说明。&lt;?php /** * 查看是否为手机端的方法 * 判断是手机访问还是是电脑访问 */ function isMobile() { // 如果有HTTP_X_WAP_PROFILE则一定是移动设备 if (isset ($_SERVER[&#39;HTTP_X_WAP_PROFILE&#39;])) return true; // 此条摘自TPM智能切换模板引擎，适合TPM开发 if(isset ($_SERVER[&#39;HTTP_CLIENT&#39;]) &amp;&amp; &#39;PhoneClient&#39; == $_SERVER[&#39;HTTP_CLIENT&#39;]) return true; //如果via信息含有wap则一定是移动设备,部分服务商会屏蔽该信息 if (isset ($_SERVER[&#39;HTTP_VIA&#39;])) //找不到为flase,否则为true return stristr($_SERVER[&#39;HTTP_VIA&#39;], &#39;wap&#39;) ? true : false; //判断手机发送的客户端标志,兼容性有待提高 if (isset ($_SERVER[&#39;HTTP_USER_AGENT&#39;])) { $clientkeywords = array( &#39;nokia&#39;,&#39;sony&#39;,&#39;ericsson&#39;,&#39;mot&#39;, &#39;samsung&#39;,&#39;htc&#39;,&#39;sgh&#39;,&#39;lg&#39;, &#39;sharp&#39;,&#39;sie-&#39;,&#39;philips&#39;,&#39;panasonic&#39;, &#39;alcatel&#39;,&#39;lenovo&#39;,&#39;iphone&#39;,&#39;ipod&#39;, &#39;blackberry&#39;,&#39;meizu&#39;,&#39;android&#39;,&#39;netfront&#39;, &#39;symbian&#39;,&#39;ucweb&#39;,&#39;windowsce&#39;,&#39;palm&#39;, &#39;operamini&#39;,&#39;operamobi&#39;,&#39;openwave&#39;,&#39;nexusone&#39;, &#39;cldc&#39;,&#39;midp&#39;,&#39;wap&#39;,&#39;mobile&#39; ); //使用正则从HTTP_USER_AGENT中查找手机浏览器的关键字 if (preg_match(&quot;/(&quot; . implode(&#39;|&#39;, $clientkeywords) . &quot;)/i&quot;, strtolower($_SERVER[&#39;HTTP_USER_AGENT&#39;]))) { return true; } } //协议法，因为有可能不准确，放到最后判断 if (isset ($_SERVER[&#39;HTTP_ACCEPT&#39;])) { // 如果只支持wml并且不支持html那一定是移动设备 // 如果支持wml和html但是wml在html之前则是移动设备 if ((strpos($_SERVER[&#39;HTTP_ACCEPT&#39;], &#39;vnd.wap.wml&#39;) !== false) &amp;&amp; (strpos($_SERVER[&#39;HTTP_ACCEPT&#39;], &#39;text/html&#39;) === false || (strpos($_SERVER[&#39;HTTP_ACCEPT&#39;], &#39;vnd.wap.wml&#39;) &lt; strpos($_SERVER[&#39;HTTP_ACCEPT&#39;], &#39;text/html&#39;)))) { return true; } } return false; } 使用方法根据isMobile()return的是true还是false执行相关的业务操作。例如：&lt;?php $mobileClinet = isMobile(); if (!$mobileClient) { // 执行手机访问的业务 } else { // 执行PC访问的业务 }]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MVC的一些理解]]></title>
    <url>%2Fpost%2Fb3189365.html</url>
    <content type="text"><![CDATA[MVC和三层架构MVC 可分为：Model 模型层、View 视图层、Controller 控制层；三层架构为：视图层、控制层、业务逻辑层架构中，我们可以如此分布：控制层+（（模型层数据访问层）+ 视图层）= 合理架构。数据模型层顾名思义，用来和数据库进行连接交互，SQL语句当然应该置于此。模型层中数据访问模块的功能如下：1)实现数据的读取与存储操作。2)实现事务处理。界面视图层主要是处理和用户进行交互的界面，显示结果或者接受输入。视图层中用户界面模块的功能如下：1)与用户的交互，接收用户的各种输入以及输出各种提示信息或处理结果。2)对于输入的数据进行数据校验，过滤非法数据。3)向业务层发送处理请求。业务控制层进行各种逻辑判断。也就是业务逻辑的封装，如有一客户要下一个用账户付款的订单，但该客户账户内的余额不够，则不该允许此客户下订单，这种逻辑就应放在业务层。业务层中业务处理模块的功能如下：1)实现各种业务处理逻辑或处理算法。2)验证请求者的权限。3)向数据层发送数据操作的请求。4)向用户层返回处理结果。MVC的优点大部分用过程语言比如ASP、PHP开发出来的Web应用，初始的开发模板就是混合层的数据编程。例如，直接向数据库发送请求并用HTML显示，开发速度往往比较快，但由于数据页面的分离不是很直接，因而很难体现出业务模型的样子或者模型的重用性。产品设计弹性力度很小，很难满足用户的变化性需求。MVC要求对应用分层，虽然要花费额外的工作，但产品的结构清晰，产品的应用通过模型可以得到更好地体现。首先，最重要的是应该有多个视图对应一个模型的能力。在目前用户需求的快速变化下，可能有多种方式访问应用的要求。例如，订单模型可能有本系统的订单，也有网上订单，或者其他系统的订单，但对于订单的处理都是一样，也就是说订单的处理是一致的。按MVC设计模式，一个订单模型以及多个视图即可解决问题。这样减少了代码的复制，即减少了代码的维护量，一旦模型发生改变，也易于维护。 其次，由于模型返回的数据不带任何显示格式，因而这些模型也可直接应用于接口的使用。其次控制层的概念也很有效，由于它把不同的模型和不同的视图组合在一起完成不同的请求，因此，控制层可以说是包含了用户请求权限的概念。最后，它还有利于软件工程化管理。由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化产生管理程序代码。MVC的不足增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。目前，一般高级的界面工具或构造器不支持MVC架构。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成使用MVC的困难。]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP开发安全问题总结]]></title>
    <url>%2Fpost%2Ffafef4eb.html</url>
    <content type="text"><![CDATA[引言提供Internet服务时，在开发代码时必须始终牢记安全性。大多数PHP脚本对安全问题都不敏感；特别是对大多数没有经验的开发者来说。但是，基于对代码重要性，非常有必要采用一致的安全策略。当你在服务器上放置任何财产有关的东西时，很可能会有人试图随便破解它。创建一个论坛程序或任何类型的购物车，被攻击的可能性就会有所上升。背景以下是保护您的网络内容的一些一般安全准则：不要相信表单利用表单攻击是很寻常的。通过使用简单的JavaScript技巧，您可以限制您的表单以仅允许的字段。对于一般的Javascript前台验证，由于无法得知用户的行为，例如用户关闭了浏览器的Javascript引擎或发布自定义表单数据时，客户端验证会弹出窗口。用户主要通过表单参数与脚本进行交互，因此它们也成了最大的安全风险。这告诉我们什么？要始终验证传递给PHP脚本的任何数据。在本文中，我们将向您展示如何分析和防止跨站点脚本（XSS）攻击，严重的话会劫持你的用户凭据。您还将了解如何防止可能污染或破坏数据的MySQL注入攻击。不要相信用户要始终假设您的网站收集的每一条数据都充满了有害的代码。对每条数据都要进行过滤，即使你肯定没有人试图攻击你的应用。关闭全局变量最大安全漏洞是启用了register_globals配置参数。不过幸运的是，它在PHP 4.2及更高版本中默认关闭。如果register_globals打开，那么你可以通过在服务器的php.ini文件中将register_globals变量设置为Off来禁用此功能。register_globals = Off 新手程序员查看注册的全局变量是一种便利，但他们没有意识到这个设置有多危险。启用了全局变量的服务器会自动将全局变量分配给任何表单参数。为了了解这是如何工作的以及为什么这是危险的，让我们看一个例子。假设您有一个名为process.php的脚本，它将表单数据输入到您的用户数据库中。原始表单看起来像这样：&lt;input name=&quot;username&quot; type=&quot;text&quot; size=&quot;15&quot; maxlength=&quot;64&quot;&gt; 运行process.php时，启用了已注册全局变量的PHP会将此参数的值放入$ username变量中。通过$ _POST [&#39;username&#39;]或$ _GET [&#39;username&#39;]可以节省一些打字输入。但不幸的是，这也造成了一个安全问题。因为PHP为通过GET或POST参数发送到脚本的任何值设置了一个变量，如果你没有显式初始化变量并且你不希望有人操纵它，这是一个大问题。以下面的脚本为例 - 如果$ authorized变量为true，它会向用户显示机密数据。在正常情况下，仅当用户已通过假设的authenticated_user()函数进行了正确的身份验证时，$ authorized变量才会设置为true。但是如果你有register_globals活动，任何人都可以发送一个GET参数，如authorized = 1来覆盖这个：&lt;?php // Define $authorized = true only if user is authenticated if (authenticated_user()) { $authorized = true; } ?&gt; 这个场景寓意是你应该从预定义的服务器变量中提取表单数据。通过发布的表单传递到您的网页的所有数据都会自动存储在名为$ _POST的大型数组中，并且所有GET数据都存储在名为$ _GET的大型数组中。文件上载信息存储在名为$ _FILES的特殊数组中。此外，还有一个名为$ _REQUEST的组合变量。要从POST方法表单访问用户名字段，请使用$ _POST [&#39;username&#39;]。如果用户名在URL中，请使用$ _GET [&#39;username&#39;]。如果您不关心值的来源，请使用$ _REQUEST [&#39;username&#39;]。&lt;?php $post_value = $_POST[&#39;post_value&#39;]; $get_value = $_GET[&#39;get_value&#39;]; $some_variable = $_REQUEST[&#39;some_value&#39;]; ?&gt; $ _REQUEST是$ _GET，$ _POST和$ _COOKIE数组的联合。如果您有两个或多个相同参数名称的值，请注意PHP使用的值。默认顺序是cookie，POST，然后是GET。推荐的安全配置选项SQL注入攻击防止基本的XSS攻击使用SafeHTML使用单向哈希保护数据使用Mcrypt加密数据生成随机密码未完待续……查看原文]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitee(码云)、Github同时配置ssh key]]></title>
    <url>%2Fpost%2Fc70e21e5.html</url>
    <content type="text"><![CDATA[创建gitee和github的ssh keycd ~/.ssh ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 替换正确的邮箱，按enterGenerating public/private rsa key pair. Enter file in which to save the key (/c/Users/FlyingHorse/.ssh/id_rsa): id_rsa.gitee 创建gitee的ssh key时输入id_rsa.gitee，创建github的ssh key时输入id_rsa.github，接着一路按enter，直到如下输出：Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in id_rsa.gitee. Your public key has been saved in id_rsa.gitee.pub. The key fingerprint is: SHA256:lmjU8A4k+r6liYJmENBPM/7Frx3XDg98VeWvIQ9dLyw xxxxx@xxxxx.com The key&#39;s randomart image is: +---[RSA 2048]----+ | . . o o| |. ..+o + ..| |. .+ oo.o +| |. .o. +o. o .+| | . ..o.S. .E.=.o| |. . ... o ==o+ | |o . . o o *o | |oo . = . . o | |o.. + | +----[SHA256]-----+ 复制public key查看公钥：gitee输入对应文件名id_rsa.gitee.pub，github输入id_rsa.github.pubcat id_rsa.gitee.pub 将输出的内容复制到gitee或github的ssh中保存ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDZbvgUEj3XAXH4HkW27ibdXgV6VHdr A9/WdSDHtiiC55mjPvxj3OtPxIbpeJmhWyHiJWR6uUuK+gkb//O51uWCPhHq xKR7+45tZ9jHqXW+hEKPp+odQgc+3hiHAjTkn3JGeIJlQp2UdJCDHBrp+kcg Veg91+y7cU3ufaUQ/hpDrCgn6uvwjwJgnDhV9DYi+gFUFe7LUwa1o4nfwg43 ycuOOuT7c6VO2dj/0pLRUVTPQYu/C3kaaPVedir7mKIu/dM6Ec44bhYTp1Dq qp8BO42Cfo+n+dempqYTe2wcPvuDjSj884IATc/KvBfc86Yd2Uj7NI7li90Y 3i6adoxUIWQh xxxxx@xxxxx.com 创建配置文件为了解决ssh冲突，在.ssh文件夹中创建config文件（注意这里没有后缀名），添加以下内容以区分两个ssh key# gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.gitee # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa.github 测试连接输入：ssh -T git@gitee.com 若返回如下输出，则gitee则连接正常Welcome to Gitee.com, yourname! 输入：ssh -T git@github.com 若返回如下输出，则github则连接正常Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 更多跟git相关知识可以参考《Pro Git》 https://www.git-scm.com/book/zh/v2]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用PHPStrom安装laravel]]></title>
    <url>%2Fpost%2F793c95ad.html</url>
    <content type="text"><![CDATA[项目安装设置打开软件选择create new porject,进入创建项目窗口，选择Composer Project。按照截图所示设置相应的Location（安装目录）、勾选Download composer.phar from getcomposer.org、Package输入laravel/laravel并在查找的结果中选择laravel/laravel。最后点击Create开始创建。整个安装过程的时间由于网络的环境不同有所差异。安装完成后可以在phpstrom的Event Log查看的相应的消息。Composer​ Project was successfully created by Composer.​ Show in log点击Show in log就可以查看具体的安装日志。至此这个项目就相当安装好了。设置版本控制打开project工作区全选这个项目下的文件，然后取消选择composer.phar。然后在顶部的菜单栏里选择VCS-&gt;Enable Version Control Integration这时候会弹出版本控制工具的对话框。我这边是设置为Git。点击OK确定。选择Version Control会弹出如下界面，点击绿色小箭头。此时就会弹出git的提交信息界面，按照截图所示进行操作：选择要git提交的文件，因为是第一次提交可以把Before Commit下的Optimize import和Perform code analysis取消掉。最后填写Commit Message点击Commit确认提交。至此git的初始设置就相当于完成了。安装laravel支持插件实现代码自动补全和检查可以安装Laravel Plugin这个插件。点击File-&gt;Plugin在Marketplace里搜索Laravel Plugin选择安装并重启IDE。重启后再打开设置界面。找到Languages &amp; Frameworks-&gt;PHP-&gt;Laravel勾选Enable plugin for this project。点击Aplay确认应用。安装Laravel Debugbar 扩展包在菜单栏依次选择Tools-&gt;composer-&gt;Manage dependencies。在弹出的窗口里输入barryvdh/laravel-debugbar。选择要安装的版本Version to install，我这边选择最新的稳定版V3.2.1再次打开部署的网站页面，就可以看到优雅的debug bar了。安装其他的扩展包也可以按照这个方法进行安装。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>laravel</tag>
        <tag>PHPstrom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 进行数据迁移（migration）报错解决办法]]></title>
    <url>%2Fpost%2Fa754c2fd.html</url>
    <content type="text"><![CDATA[Laravel 5.4 把默认数据库字符集更改成 utf8mb4，作为对存储 emojis 的支持。只要你运行的是 MySQL v5.7.7 及更高版本，那么你就下面提到的错误。SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long;max key length is 767 bytes (SQL: alter table users add unique users_email_unique (email))对于 MariaDB 或旧版本的 MySQL 的程序，可以找到：/app/Providers/AppServiceProvider.php在 boot 方法内设置默认字符串的长度：use Illuminate\Support\Facades\Schema; public function boot() { Schema::defaultStringLength(191); } 再次执行:php artisan migrate 可以看到返回如下信息。至此报错问题就解决了^.^Migration table created successfully.Migrating: 2014_10_12_000000_create_users_tableMigrated: 2014_10_12_000000_create_users_tableMigrating: 2014_10_12_100000_create_password_resets_tableMigrated: 2014_10_12_100000_create_password_resets_table]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>phpstrom</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Facebook账号一键登录]]></title>
    <url>%2Fpost%2Fb05283f6.html</url>
    <content type="text"><![CDATA[公司最近做的一个项目要求使用Facebook实现一键登录的功能。所谓的Facebook登录就是获取用户在Facebook的资料，通过这些资料（邮箱等）登录或者注册目标网站。这中间Facebook提供了相应的接口，通过这个接口获取用户授权就能拿到相应的用户资料。整个过程完成下来还算比较顺利，这边就做一下记录。申请应用及配置在使用之前，需要先在Facebook开发者平台注册账号，新建应用，然后获取新建应用的编号APPID。相应的流程开发平台写的还是相对比较清楚的，这里就不一一赘述。其中要注意的是：有效 OAuth 跳转 URL要填写正确。还有一个是隐私政策网站的填写。这个关乎应用能不能的公开发布。找到开发平台的控制面板下面有个设置-&gt;基本。在隐私权政策网址里可以填http://wp4fb.com/how-to-add-a-privacy-policy-to-your-apps/（这个不是唯一的，填写的地址有效即可）。然后保存更改。然后就可以点击应用发布开关，弹窗提示点击确定即可。最后效果是这样的：检查登录状态加载网页时应采取的第一步是检查用户是否已使用 Facebook 登录功能登录您的应用。调用 FB.getLoginStatus 即可开始此流程。此函数会触发 Facebook 调用，获取登录状态，并调用包含结果的回调函数。下面是将在页面加载期间运行以检查用户登录状态的部分代码：FB.getLoginStatus(function(response) { statusChangeCallback(response); }) 提供给回调的response对象包括的字段：{ // 用户登录状态 status: &#39;connected&#39;, authResponse: { // 包括应用用户的访问口令 accessToken: &#39;...&#39;, // 口令到期且需要更新的 UNIX 时间 expiresIn:&#39;...&#39;, // 登录过期和请求重新授权之前的时长（以秒为单位） reauthorize_required_in:&#39;...&#39; // 经签名的参数，其中包括应用用户的信息。 signedRequest:&#39;...&#39;, // 应用用户的编号 userID:&#39;...&#39; } } 知道用户的登录状态后，应用就可以执行以下操作之一：如果用户登录了 Facebook 和您的应用，可将他们重定向至应用的登录后体验。如果用户未登录您的应用，或未登录 Facebook，则可以通过 FB.login()呈现登录对话框，以此提示他们登录，或显示“登录”按钮。使用JavaScript SDK提供的登录按钮添加按钮代码&lt;div id=&quot;fb-root&quot;&gt;&lt;/div&gt; &lt;script&gt;(function(d, s, id) { var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = &#39;https://connect.facebook.net/zh_CN/sdk.js#xfbml=1&amp;version=v3.2&amp;appId=申请的应用编号&amp;autoLogAppEvents=1&#39;; fjs.parentNode.insertBefore(js, fjs); }(document, &#39;script&#39;, &#39;facebook-jssdk&#39;)); &lt;/script&gt; &lt;!-- button --&gt; &lt;div class=&quot;fb-login-button&quot; data-size=&quot;large&quot; data-button-type=&quot;continue_with&quot; data-auto-logout-link=&quot;false&quot; data-use-continue-as=&quot;false&quot;&gt;&lt;/div&gt; 获取用户信息function fb_login() { FB.login(function(response) { if (response.status === &#39;connected&#39;) { // 获取用户id、Email、名称等 FB.api(&#39;/me?fields=id,email,first_name,last_name,gender&#39;, function(response) { // 获取信息后的相关操作 console.log(response); }); } else { alert(&#39;login fail&#39;); } }, { scope: &#39;public_profile,email&#39; }); } 完整实例代码&lt;script&gt; window.fbAsyncInit = function() { FB.init({ appId: &#39;&#39;, // 这里需要改成15位你创建的Facebook应用编号 cookie: true, xfbml: true, version: &#39;v3.2&#39; }); FB.AppEvents.logPageView(); }; (function(d, s, id) { var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) { return; } js = d.createElement(s); js.id = id; js.src = &quot;//connect.facebook.net/en_US/sdk.js&quot;; fjs.parentNode.insertBefore(js, fjs); }(document, &#39;script&#39;, &#39;facebook-jssdk&#39;)); &lt;/script&gt; &lt;script&gt; function fb_login() { FB.login(function(response) { if (response.status === &#39;connected&#39;) { FB.api(&#39;/me?fields=id,email,first_name,last_name,gender&#39;, function(response) { // 获取信息后的相关操作 }); } else { alert(&#39;login fail&#39;); } }, {scope: &#39;public_profile,email&#39;}); } &lt;/script&gt; &lt;div class=&quot;login-btn-box&quot; &gt; &lt;button onclick=&quot;fb_login();&quot;&gt;Login with Facebook&lt;/button&gt; &lt;/div&gt; 总结Facebook JavaScript SDK在最新的3.2版本中跳转 URI 和 JavaScript SDK 强制使用 HTTPS。Facebook是使用标准的 OAuth 客户端口令流程。其授权过程跟其他OAuth没什么区别，按照官网的流程走一般都能成功。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Facebook</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPStrom文件修改标星提示]]></title>
    <url>%2Fpost%2F9ffb46c.html</url>
    <content type="text"><![CDATA[phpstrom设置标星提示文件修改Eclipse中文件修改后没有保存前文件都会有星号提示，phpstrom默认没有提示，但是可以通过如下设置完成：File -&gt; Settings -&gt; Editor -&gt; General -&gt; Editor Tabs: Mark modified (*)]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>phpstrom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP代码风格规范]]></title>
    <url>%2Fpost%2Fe54bdc58.html</url>
    <content type="text"><![CDATA[本指南扩展和扩展了基本编码标准PSR-1。本指南的目的是在扫描来自不同作者的代码时减少认知摩擦。它通过枚举一组共享规则和对如何格式化PHP代码的期望来实现。这里的风格规则源于各个成员项目之间的共性。当各个作者跨多个项目进行协作时，在所有这些项目中使用一套指南会很有帮助。因此，本指南的好处不在于规则本身，而在于共享这些规则。本文档中的关键词“必须”，“必须”，“必需”，“应该”，“不应该”，“应该”，“不应该”，“推荐”，“可以”和“可选”按照RFC 2119中的描述进行解释。1. 概览代码 必须 遵循 [PSR-1] 中的编码规范 。代码 必须 使用 4 个空格符而不是「Tab 键」进行缩进。每行的字符数 应该 软性保持在 80 个之内，理论上 一定不可 多于 120 个，但 一定不可 有硬性限制。每个 namespace 命名空间声明语句和 use 声明语句块后面，必须 插入一个空白行。类的开始花括号（{） 必须 写在函数声明后自成一行，结束花括号（}）也 必须 写在函数主体后自成一行。方法的开始花括号（{） 必须 写在函数声明后自成一行，结束花括号（}）也 必须 写在函数主体后自成一行。类的属性和方法 必须 添加访问修饰符（private、protected 以及 public），abstract 以及 final 必须 声明在访问修饰符之前，而 static 必须 声明在访问修饰符之后。控制结构的关键字后 必须 要有一个空格符，而调用方法或函数时则 一定不可 有。控制结构的开始花括号（{） 必须 写在声明的同一行，而结束花括号（}） 必须 写在主体后自成一行。控制结构的开始左括号后和结束右括号前，都 一定不可 有空格符。1.1. 示例本示例将作为下文规则的快速概览：&lt;?php namespace Vendor\Package; use FooInterface; use BarClass as Bar; use OtherVendor\OtherPackage\BazClass; class Foo extends Bar implements FooInterface { public function sampleMethod($a, $b = null) { if ($a === $b) { bar(); } elseif ($a &gt; $b) { $foo-&gt;bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { // method body } } 2. 通则2.1. 基本编码准则代码 必须 符合 PSR-1 中的所有规范。2.2. 文件所有 PHP 文件 必须 使用 Unix LF (linefeed) 作为行的结束符。所有 PHP 文件 必须 以一个空白行作为结束。纯 PHP 代码文件 必须 省略最后的 ?&gt; 结束标签。2.3. 行行的长度 一定不可 有硬性的约束。软性的长度约束 必须 要限制在 120 个字符以内，若超过此长度，带代码规范检查的编辑器 必须 要发出警告，不过 一定不可 发出错误提示。每行 不该 多于80个字符，大于80字符的行 应该 折成多行。非空行后 一定不可 有多余的空格符。空行 可以 使得阅读代码更加方便以及有助于代码的分块。每行 一定不可 存在多于一条语句。2.4. 缩进代码 必须 使用 4 个空格来进行缩进， 并且 一定不能 使用 tab 键来缩进。注：仅使用空格，而不是使用空格和 tab 键混在一起， 能帮助避免在查看代码差异，打补丁，查看提交历史，以及进行注解时产生问题。使用空格也使得代码对齐更轻松。2.5. 关键字与 True/False/NullPHP 的 关键字 必须 使用小写形式。PHP 的常量 true， false， 还有 null 必须 使用小写形式。3. 命名空间和使用声明namespace 声明之后 必须 存在一个空行。所有的 use 声明 必须 位于 namespace 声明之后。每条 use 声明 必须 只有一个 use 关键字。use 语句块之后 必须 存在一个空行。例如：&lt;?php namespace Vendor\Package; use FooClass; use BarClass as Bar; use OtherVendor\OtherPackage\BazClass; // ... additional PHP code ... 4. 类、属性和方法此处的「类」泛指所有的「class类」、「接口」以及「traits 可复用代码块」。4.1. 扩展与继承关键词 extends 和 implements 必须 写在类名称的同一行。类的开始花括号 必须 独占一行，结束花括号也 必须 在类主体后独占一行。&lt;?php namespace Vendor\Package; use FooClass; use BarClass as Bar; use OtherVendor\OtherPackage\BazClass; class ClassName extends ParentClass implements \ArrayAccess, \Countable { // constants, properties, methods } implements 的继承列表也 可以 分成多行，这样的话，每个继承接口名称都 必须 分开独立成行，包括第一个。&lt;?php namespace Vendor\Package; use FooClass; use BarClass as Bar; use OtherVendor\OtherPackage\BazClass; class ClassName extends ParentClass implements \ArrayAccess, \Countable, \Serializable { // constants, properties, methods } 4.2. 属性每个属性都 必须 添加访问修饰符。一定不可 使用关键字 var 声明一个属性。每条语句 一定不可 定义超过一个属性。不该 使用下划线作为前缀，来区分属性是 protected 或 private。以下是属性声明的一个范例：&lt;?php namespace Vendor\Package; class ClassName { public $foo = null; } 4.3. 方法所有方法都 必须 添加访问修饰符。不该 使用下划线作为前缀，来区分方法是 protected 或 private 访问修饰符。方法名称后 一定不可 有空格符，其开始花括号 必须 独占一行，结束花括号也 必须 在方法主体后单独成一行。参数左括号后和右括号前 一定不可 有空格。一个标准的方法声明可参照以下范例，留意其括号、逗号、空格以及花括号的位置。&lt;?php namespace Vendor\Package; class ClassName { public function fooBarBaz($arg1, &amp;$arg2, $arg3 = []) { // method body } } 4.4. 方法的参数参数列表中，每个逗号后面 必须 要有一个空格，而逗号前面 一定不可 有空格。有默认值的参数，必须 放到参数列表的末尾。&lt;?php namespace Vendor\Package; class ClassName { public function foo($arg1, &amp;$arg2, $arg3 = []) { // method body } } 参数列表 可以 分列成多行，这样，包括第一个参数在内的每个参数都 必须 单独成行。拆分成多行的参数列表后，结束括号以及方法开始花括号 必须 写在同一行，中间用一个空格分隔。&lt;?php namespace Vendor\Package; class ClassName { public function aVeryLongMethodName( ClassTypeHint $arg1, &amp;$arg2, array $arg3 = [] ) { // method body } } 4.5. abstract, final, 和 static 关键字需要添加 abstract 或 final 声明时，必须 写在访问修饰符前，而 static 则 必须 写在其后。&lt;?php namespace Vendor\Package; abstract class ClassName { protected static $foo; abstract protected function zim(); final public static function bar() { // method body } } 4.6. 方法及函数调用方法及函数调用时，方法名或函数名与参数左括号之间 一定不可 有空格，参数右括号前也 一定不可 有空格。每个逗号前 一定不可 有空格，但其后 必须 有一个空格。&lt;?php bar(); $foo-&gt;bar($arg1); Foo::bar($arg2, $arg3); 参数 可以 分列成多行，此时包括第一个参数在内的每个参数都 必须 单独成行。&lt;?php $foo-&gt;bar( $longArgument, $longerArgument, $muchLongerArgument ); 5. 控制结构控制结构的基本规范如下：控制结构关键词后 必须 有一个空格。左括号 ( 后 一定不可 有空格。右括号 ) 前也 一定不可 有空格。右括号 ) 与开始花括号 { 间 必须 有一个空格。结构体主体 必须 要有一次缩进。结束花括号 } 必须 在结构体主体后单独成行。每个结构体的主体都 必须 被包含在成对的花括号之中，这能让结构体更加标准化，以及减少加入新行时，出错的可能性。5.1. if, elseif, else标准的 if 结构如下代码所示，请留意「括号」、「空格」以及「花括号」的位置，注意 else 和 elseif 都与前面的结束花括号在同一行。&lt;?php if ($expr1) { // if body } elseif ($expr2) { // elseif body } else { // else body; } 应该 使用关键词 elseif 代替所有 else if ，以使得所有的控制关键字都像是单独的一个词。5.2. switch, case标准的 switch 结构如下代码所示，留意括号、空格以及花括号的位置。case 语句 必须 相对 switch 进行一次缩进，而 break 语句以及 case 内的其它语句都 必须 相对 case 进行一次缩进。如果存在非空的 case 直穿语句，主体里 必须 有类似 // no break 的注释。&lt;?php switch ($expr) { case 0: echo &#39;First case, with a break&#39;; break; case 1: echo &#39;Second case, which falls through&#39;; // no break case 2: case 3: case 4: echo &#39;Third case, return instead of break&#39;; return; default: echo &#39;Default case&#39;; break; } 5.3. while, do while一个规范的 while 语句应该如下所示，注意其「括号」、「空格」以及「花括号」的位置。&lt;?php while ($expr) { // structure body } 同样的，标准的 do while 语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。&lt;?php do { // structure body; } while ($expr); 5.4. for标准的 for 语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。&lt;?php for ($i = 0; $i &lt; 10; $i++) { // for body } 5.5. foreach标准的 foreach 语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。&lt;?php foreach ($iterable as $key =&gt; $value) { // foreach body } 5.6. try, catch标准的 try catch 语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。&lt;?php try { // try body } catch (FirstExceptionType $e) { // catch body } catch (OtherExceptionType $e) { // catch body } 6. 闭包闭包声明时，关键词 function 后以及关键词 use 的前后都 必须 要有一个空格。开始花括号 必须 写在声明的同一行，结束花括号 必须 紧跟主体结束的下一行。参数列表和变量列表的左括号后以及右括号前，一定不可 有空格。参数和变量列表中，逗号前 一定不可 有空格，而逗号后 必须 要有空格。闭包中有默认值的参数 必须 放到列表的后面。标准的闭包声明语句如下所示，注意其「括号」、「空格」以及「花括号」的位置。&lt;?php $closureWithArgs = function ($arg1, $arg2) { // body }; $closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) { // body }; 参数列表以及变量列表 可以 分成多行，这样，包括第一个在内的每个参数或变量都 必须 单独成行，而列表的右括号与闭包的开始花括号 必须 放在同一行。以下几个例子，包含了参数和变量列表被分成多行的多情况。&lt;?php $longArgs_noVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) { // body }; $noArgs_longVars = function () use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_longVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_shortVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ($var1) { // body }; $shortArgs_longVars = function ($arg) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; 注意，闭包被直接用作函数或方法调用的参数时，以上规则仍然适用。&lt;?php $foo-&gt;bar( $arg1, function ($arg2) use ($var1) { // 主体 }, $arg3 ); 7. 总结本指南故意删除了许多风格与实践， 它们包括但不限于：全局变量和常量的声明函数声明运算符与赋值行间对齐注释与文档描述块类名前缀与后缀最佳实践本指南将来的修订和扩展 可能 会弥补上述或其他风格与最佳实践。【阅读原文】]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PSR</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 基本代码标准]]></title>
    <url>%2Fpost%2Fae1a60a8.html</url>
    <content type="text"><![CDATA[根据PSR Workflow Bylaw，每个PSR都具有正在处理的状态。一旦提案通过了入口投票，它将在此处列为“草稿”。除非PSR标记为“已接受”，否则可能会发生变化。草稿可能会发生巨大变化，但审核只会有微小的变化。As also described in the PSR Workflow Bylaw。提案的编辑或编辑们基本上是PSR的主要贡献者和作者，他们得到两位投票成员的支持。这些投票成员是协调员，负责管理审查阶段和投票以及二次发起人。PSR-1：基本编码标准标准的这一部分包括应该被认为是确保共享PHP代码之间高水平技术互操作性所需的标准编码元素。本文档中的关键词“必须”，“必须”，“必需”，“应该”，“不应该”，“应该”，“不应该”，“推荐”，“可以”和“可选”按照RFC 2119中的描述进行解释。1. 概述文件必须只使用&lt;?php和&lt;?=标签。对于PHP代码，文件必须仅使用没有BOM的UTF-8。文件应该声明符号（类，函数，常量等）或引起副作用（例如生成输出，更改.ini设置等），但不应该同时出现。命名空间和类必须遵循“自动加载”PSR：[PSR-0，PSR-4]。类名必须使用首字母大写的驼峰式进行声明。类常量必须以全部大写形式用下划线分隔符声明。方法名必须使用首字母小写的驼峰式进行。2. 文件2.1. PHP标签PHP代码必须使用长标签&lt;?php?&gt;或短输出标签&lt;?=?&gt;；不能使用其他标签变体。2.2. 字符编码PHP代码必须只使用不带BOM的UTF-8编码。2.3. 副作用一份 PHP 文件中 应该 要不就只定义新的声明，如类、函数或常量等不产生 副作用 的操作，要不就只书写会产生 副作用 的逻辑操作，但 不该 同时具有两者。「副作用」(side effects) 一词的意思是，仅仅通过包含文件，不直接声明类、函数和常量等，而执行的逻辑操作。「副作用」包含却不仅限于：生成输出，明确使用require或include，连接到外部服务，修改ini设置，发出错误或异常，修改全局或静态变量，读取或写入一个文件，等等。以下是具有声明和副作用的文件示例;即要避免的一个例子：&lt;?php // side effect: change ini settings ini_set(&#39;error_reporting&#39;, E_ALL); // side effect: loads a file include &quot;file.php&quot;; // side effect: generates output echo &quot;&lt;html&gt;\n&quot;; // declaration function foo() { // function body } 以下示例是包含没有副作用的声明的文件;即效仿的例子：&lt;?php // declaration function foo() { // function body } // conditional declaration is *not* a side effect if (! function_exists(&#39;bar&#39;)) { function bar() { // function body } } 3. 命名空间和类名命名空间和类名 必须 遵循『自动加载』规范：[PSR-0，PSR-4]。这意味着每个类都独立为一个文件，并且至少在一个层次的命名空间内，那就是：顶级组织名（vendor name）。类名 必须大写开头的驼峰命名方式声明。PHP 5.3 及更高版本的代码 必须 使用正式的命名空间。例如&lt;?php // PHP 5.3 and later: namespace Vendor\Model; class Foo { } PHP 5.2 及更低版本 应该 使用伪命名空间，约定俗成，以顶级组织名称 Vendor_ 为类名前缀：&lt;?php // PHP 5.2.x and earlier: class Vendor_Model_Foo { } 4. 类的常量、属性和方法此处的「类」指代所有的类、接口以及可复用代码块（traits）4.1. 常量类的常量中所有字母都 必须 大写，词间以下划线分隔。例如：&lt;?php namespace Vendor\Model; class Foo { const VERSION = &#39;1.0&#39;; const DATE_APPROVED = &#39;2012-06-01&#39;; } 4.2. 属性类的属性命名 可以 遵循：大写开头的驼峰式小写开头的驼峰式下划线分隔式本规范不做强制要求，但无论遵循哪种命名方式，都 应该 在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。4.3. 方法方法名称 必须 用小写开头的驼峰命名规范。【阅读原文】]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PSR</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
</search>
